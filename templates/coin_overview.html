{% extends "base.html" %}

{% load i18n %}
{% load humanize %}
{% load btc_formats %}

{% block content %}

<div class="container">

<form role="form" method="post" action="{% url "home" %}">
  {% load crispy_forms_tags %}
  {{ form|crispy }}
  {% csrf_token %}
  <p class="text-center">
    <button type="submit" class="btn btn-primary btn-lg">{% trans "Search" %} </button>
  </p>
</form>

<br />

<h4>Recent Blocks</h4>

<table class="table">
  <th>Height</th>
  <th>Age</th>
  <th>Transactions</th>
  <th>Total Sent</th>
  <th>Total Fees</th>
  {% for block in recent_blocks %}
    <tr>
      <td>
        <a href="{% url 'block_overview' coin_symbol block.height %}">{{ block.height }}</a>
      </td>
      <td>{{ block.received_time|naturaltime }}</td>
      <td>{{ block.n_tx }}</td>
      <td>{{ block.total|satoshis_to_btc_rounded|intcomma }} {{ coin_symbol|coin_symbol_to_currency_name }}</td>
      <td>{{ block.fees|satoshis_to_btc_rounded|intcomma }} {{ coin_symbol|coin_symbol_to_currency_name }}</td>
    </tr>
  {% endfor %}
</table>
<br />
<br />

<div id="newtx-section" style="display:none">
  <h4>Latest Transactions</h4>

  <table class="table table-striped">
    <tr id="latest-txs">
      <th>Transaction Hash</th>
      <th>{{ coin_symbol|coin_symbol_to_currency_name }}</th>
      <th>Time</th>
    </tr>
    <tr class="new-tx" style="display;none"></tr>
  </table>

  <br />
  <p>
  Note: Blockypher is a lot faster than other blockchain APIs, so these transactions may take a bit to appear on other sites.
  </p>
</div>

</div>
{% endblock content %}

{% block extra_js %}
  <script>

    $(document).ready(function(){

      var total_ws_received = 0;
      var MAX_WS_TO_RECEIVE = 1000;

      function create_ws() {
        console.log('Creating new websocket...');
        ws = new WebSocket('{{ coin_symbol|coin_symbol_to_wss }}');
      }

      create_ws();

      function send_ping() {
        // Send pings at regular interval:
        if (total_ws_received < MAX_WS_TO_RECEIVE) {
          console.log('Sending websocket ping...');
          ws.send(JSON.stringify({event: "ping"}));
          // Trigger self recursively
          setTimeout(send_ping, 20000);
        } else {
          console.log('Not sending ping because MAX_WS_TO_RECEIVE reached');
        }
      }

      ws.onmessage = function(evt) {

        // Weak protection against too much activity
        total_ws_received += 1;
        if (total_ws_received > MAX_WS_TO_RECEIVE) {
          ws.close();
        }

        var data = JSON.parse(evt.data);

        if ( data.hash && $('#' + data.hash).length == 0 ) {
          $('#newtx-section').fadeIn(); // only matters the first time
          var btc_rounded = satoshis_to_btc(data.total);
          var seconds_ago = convert_time_to_seconds_ago(data.received)
          var time_ago_formatted = format_seconds_ago(seconds_ago);

          to_insert = $('<tr>').attr('class', "new-tx").attr('id', data.hash).append(
          $('<td>').append($('<a>').attr('href', '/{{ coin_symbol }}/tx/'+data.hash).text(data.hash.substring(0,12))).append('...'),
            $('<td>').append(btc_rounded+' {{ coin_symbol|coin_symbol_to_currency_name }}'),
            $('<td>').attr('class', "timing").attr('received', data.received).append(time_ago_formatted)
          )
          $('.new-tx').first().before(to_insert);
          // New row effect:
          $('.new-tx').first().hide().fadeIn();

          if ( $('.new-tx').length > 10 ) {
            // Trim end of list once long
            $('.new-tx').last().fadeOut().remove();
          }

        }

      }

      ws.onopen = function() {
        console.log('Connection established.');
        ws.send(JSON.stringify({'event': 'unconfirmed-tx'}));
        send_ping();
      };

      ws.onclose = function() {
        console.log('Connection closed');
        if (total_ws_received < MAX_WS_TO_RECEIVE) {
          console.log('Creating new websocket to replace old one...');
          create_ws();
        }

      };

    // Update timing
    function update_timing() {
      console.log('Updating timing...');

      var times_array = $('.timing');
      var times_length = times_array.length;
      for (var i = 0; i < times_length; i++) {
        times_array[i].innerHTML = format_seconds_ago(convert_time_to_seconds_ago(times_array[i].getAttribute('received')));
      }
      // Call self recursively
      setTimeout(update_timing, 10000);
    }

    // Continuously update times as they become stale
    update_timing();

    })

  </script>
{% endblock extra_js %}
